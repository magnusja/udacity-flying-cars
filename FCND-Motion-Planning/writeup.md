## Project: 3D Motion Planning
![Quad Image](./misc/enroute.png)

---


# Required Steps for a Passing Submission:
1. Load the 2.5D map in the colliders.csv file describing the environment.
2. Discretize the environment into a grid or graph representation.
3. Define the start and goal locations.
4. Perform a search using A* or other search algorithm.
5. Use a collinearity test or ray tracing method (like Bresenham) to remove unnecessary waypoints.
6. Return waypoints in local ECEF coordinates (format for `self.all_waypoints` is [N, E, altitude, heading], where the droneâ€™s start location corresponds to [0, 0, 0, 0].
7. Write it up.
8. Congratulations!  Your Done!

## [Rubric](https://review.udacity.com/#!/rubrics/1534/view) Points
### Here I will consider the rubric points individually and describe how I addressed each point in my implementation.  

---
### Writeup / README

#### 1. Provide a Writeup / README that includes all the rubric points and how you addressed each one.  You can submit your writeup as markdown or pdf.  

You're reading it! Below I describe how I addressed each rubric point and where in my code each point is handled.

### Explain the Starter Code

#### 1. Explain the functionality of what's provided in `motion_planning.py` and `planning_utils.py`

The first thing to notice is that there is a new state for planning. This state is active after arming the drone. The rest of the scripts a fairly similar. There are callbacks for position, velocity and state updates. The transitining function are also very similar, except that there is now a new method `plan_path()` which is responsible for all the planning steps. It sets ups some variables like `SAFETY_DISTANCE` and `TARGET_ALTITUDE`. Then it reads the 2.5D map with the obstacles. This information is then transformed to a 2D grid using the usual function `create_grid(..)` already known from the notebook execises in the videos. To create the grid the target altiude and the safety distance is necessary. The `create_grid(..)` function creates a 2D grid using the target altitude, i.e. it only accounts for obstacles in that particular altitude. The safety distance adds an artifical margin around the obstacles in the grid. After that a start and goal position are defined using the grid. After that we are using the A* path finding algorithm for finding a feasible path thorough the grid. The `a_start()` function is similar to the one used in the exercises before. The heuristic used for A* is the euclidean distance between two points in 3D space. The path through the grid generated by A* is then converted to waypoints which can be sent to our flight controller.

### Implementing Your Path Planning Algorithm

#### 1. Set your global home position

My code for this is first reading the first line of the `colliders.csv`, strips unnecessary parts so that only the values for latitude and longditude remain. After that I use the setter to set the global home position to these particular values.

#### 2. Set your current local position

First I read the current global local using `_longitude`, `_latitude` and `_altitude`. After that I convert this position to the local coordinate frame using `global_to_local`. The return values I use to set `_north`, `_east` and `_down`.

#### 3. Set grid start position from local position

In the previous step I extracted the local position, which I use now together with the grid offsets to set the starting point inside the grid.

Instead of using a grid I also implemented Probabilistic Roadmaps and created a graph structure. I noticed that creating the graph does take a lot longer than only using the grid. I used the A* algorithm from the video lectures to be able to find a way through a graph.

To set the start and goal position, I add these positions to the manually sampler to be included in the resulting points. This means start and goal position must lie in free space! 

In my code there is a flag called `use_grid` in the `plan_path()` method, which swicthes between PRM and grid based navigation.

#### 4. Set grid goal position from geodetic coords

I looked for a position on google maps, extracted latitude and longditude and convert this position to a local one using again `global_to_local`. After that I convert the local position to a position inside the grid (using the grid offsets again).

For PRM I only use the local position, the grid offsets are not necessary.

#### 5. Modify A* to include diagonal motion (or replace A* altogether)

This was an easy step. I just added these actions to the action enum with the corresponding cost, nothing else to do!

For PRM I adjusted the A* implementation to work on graphs. To create the graph and connect edges I used `KDTree` to find edges close to each other and `LineString.crosses(Polygon)` to see if there are obstacles between nodes. The latter method seems to be quite slow. How could I improve that? 

#### 6. Cull waypoints 

I first tried a simple collinearity check, and then implemented a pruning method based on bresenham. This reduces the number of waypoints to a minimum!

For PRM this is not necessary, because I do not have a grid anyways (although one could think of a different approach to prune).


### Execute the flight
#### 1. Does it work?
It works!

I noticed that pruning the waypoints is really useful. Having to many waypoints close together oftentimes leads to crashes!

### Possible extensions (if time permits)

* (local) 3D planning
* receding horizon planning or replanning
* Other algorithms like RRT, PFM


